Харківський національний університет радіоелектроніки
Факультет комп'ютерних наук
Кафедра програмної інженерії




ЗВІТ
до практичного заняття №1 з дисципліни
«Архітектура програмного забезпечення»
на тему: «Патерни проєктування»





Виконала
ст. гр. ПЗПІ-22-3
Цимбал Мілена Русланівна

Перевірив
ст. викладач кафедри ПІ
Сокорчук Ігор Петрович






Харків 2025
1 ІСТОРІЯ ЗМІН

№	Дата	Версія звіту	Опис змін та виправлень
1	23.04.2025	0.1	Додано розділ завдання, опис виконаної роботи
2	24.04.2025	0.1	Сформульовано висновки роботи
3	25.04.2025	0.1	Наведено слайди презентації в додатку Б
4	26.04.2025	0.1	Наведено приклади програмного коду в додатку В
5	28.04.2025	0.1	Створено відеозапис доповіді та наведено в додатку А

2 ЗАВДАННЯ

Завдання на дане практичне заняття — дослідити та проаналізувати патерн проєктування "Стан", а також продемонструвати його застосування на практиці.

3 ОПИС ВИКОНАНОЇ РОБОТИ

	У межах виконаної роботи було підготовлено детальну доповідь та відео, в якому представлено презентацію на тему патерну проєктування "Стан", що дозволяє об’єктам змінювати свою поведінку залежно від внутрішнього стану. Посилання на відео та слайди презентації наведено в додатках А та Б відповідно. Під час підготовки доповіді було розглянуто типові проблеми, які виникають при реалізації логіки станів у вигляді умовних конструкцій (наприклад, if-else або switch). Такий підхід часто ускладнює читання коду, його підтримку й розширення. Особливо це стає проблемою в системах, де об’єкти мають багато станів і кожен стан має власну поведінку. Патерн "Стан" було запропоновано як ефективне рішення для організації такої логіки. Він дозволяє винести поведінку, пов’язану з конкретним станом, у окремі класи. Це знижує зв'язність між компонентами, робить код чистішим, модульнішим і розширюваним. Об’єкт делегує виконання дій відповідному стану, а сам стан може змінювати об’єкт, переводячи його в інший стан. У роботі було розглянуто приклади застосування патерну "Стан", зокрема: світлофор, який циклічно переходить між станами "червоне", "жовте", "зелене", а також систему сигналізації, яка може бути активованою, видавати тривогу або деактивованою, змінюючи поведінку залежно від дій користувача. Усі приклади наведено в додатку В. Вони демонструють переваги застосування патерну у випадках, коли поведінка об’єкта має змінюватися динамічно. Також було розглянуто як переваги, так і потенційні недоліки патерну. До переваг належать: спрощення структури коду, легкість додавання нових станів, зниження складності підтримки. Серед недоліків було вказано можливу надмірну кількість класів, яка може виникнути в системах із багатьма станами, а також складність у розумінні логіки переходів між станами для нових розробників. Загалом, патерн "Стан" виявився ефективним інструментом для організації поведінки об’єктів із множинними станами та дозволяє реалізовувати гнучкі й масштабовані рішення, особливо в контексті реальних сценаріїв, таких як UI-компоненти, автомати станів, ігрова логіка тощо.









4 ВИСНОВКИ

У результаті виконання даної практичної роботи було розглянуто патерн "Стан". Проаналізовано його переваги, недоліки та доцільність застосування в різних ситуаціях. Було підкреслено, як цей патерн дозволяє змінювати поведінку об’єкта залежно від його поточного стану без використання громіздких умовних конструкцій, що сприяє спрощенню структури коду та покращенню його підтримуваності й розширюваності. Також наведено приклади використання патерну "Стан" у реальних сценаріях, зокрема в моделюванні світлофора та системи сигналізації.




















ДОДАТОК А
Посилання на відеозапис доповіді

Відеозапис доповіді на YouTube: https://youtu.be/IARLskdtfTM
Нижче наведено хронологічний опис доповіді.
00:00 Вітання. Оголошується ім’я доповідача, його академічна група та тема доповіді. 
00:13 Зміст доповіді. Стислий огляд підтем, які буде розглянуто: визначення патерну, актуальність, приклади застосування, переваги й недоліки. 
00:43 Визначення патерну проєктування. Пояснюється, що таке патерн проєктування, його роль у спрощенні архітектури програмного забезпечення та полегшенні повторного використання рішень. 
01:31 Проблематика розробки ПЗ. Описуються складнощі, що виникають під час розробки великих систем: зростаюча складність, жорстка зв’язність між класами, ускладнення змін та підтримки. 
02:19 Визначення патерну «Стан». Надається визначення патерну «Стан» як поведінкового шаблону проєктування, який дозволяє об’єктам змінювати свою поведінку залежно від поточного стану. 
02:56 Застосування патерну «Стан». Описуються ситуації, де доречно впроваджувати цей патерн: при моделюванні об’єктів з багатьма станами, коли логіка залежить від внутрішнього стану. 
03:33 Переваги патерну «Стан». Перелічуються основні переваги: спрощення коду, покращення читабельності, уникнення великих конструкцій умовних операторів. 
04:10 Недоліки патерну «Стан». Висвітлюються недоліки: збільшення кількості класів, можливе ускладнення структури коду. 
04:33 Перший практичний приклад. Наводиться приклад реалізації патерну «Стан» у простій програмі, де об'єкт змінює поведінку відповідно до свого стану (наприклад, стан дверей: відкриті/закриті). 
06:11 Другий практичний приклад. Розглядається приклад, де патерн «Стан» допоміг зменшити залежності між модулями та зробити систему більш гнучкою. 
07:16 Висновки. Підсумовується доцільність використання патерну «Стан» у проєктуванні ПЗ, наголошується на важливості правильного вибору патерну відповідно до задачі.
























ДОДАТОК Б
Слайди презентації доповіді

 
Рисунок Б.1 – Титульний лист

 
Рисунок Б.2 – Зміст доповіді

 
Рисунок Б.3 – Патерни проєктування

 
Рисунок Б.4 – Проблематика розробки ПЗ, де патерн "Стан" є ефективним рішенням
 
Рисунок Б.5 – Визначення стану

 
Рисунок Б.6 – Коли варто використовувати
 
Рисунок Б.7 – Переваги патерну “стан”

 
Рисунок Б.8 – Недоліки патерну “стан”

 
Рисунок Б.9 – Перший практичний приклад (перша частина)

 
Рисунок Б.10 – Перший практичний приклад (друга частина)

 
Рисунок Б.11 – Другий практичний приклад

 
Рисунок Б.12 – Підсумки

 
Рисунок Б.13 – Список використаних джерел


















ДОДАТОК В
Приклад програмного коду

	Перший приклад:
  1: using System;
  2:
  3: interface IState
  4: {
  5:     void Show();
  6:     void Next(TrafficLight light);
  7: }
  8:
  9: class Red : IState
 10: {
 11:     public void Show()
 12:     {
 13:         Console.ForegroundColor = ConsoleColor.Red;
 14:         Console.WriteLine("Червоний — стоп!");
 15:         Console.ResetColor();
 16:     }
 17:
 18:     public void Next(TrafficLight light)
 19:     {
 20:         light.SetState(new Yellow());
 21:     }
 22: }
 23:
 24: class Yellow : IState
 25: {
 26:     public void Show()
 27:     {
 28:         Console.ForegroundColor = ConsoleColor.Yellow;
 29:         Console.WriteLine("Жовтий — уважно!");
 30:         Console.ResetColor();
 31:     }
 32:
 33:     public void Next(TrafficLight light)
 34:     {
 35:         light.SetState(new Green());
 36:     }
 37: }
 38:
 39: class Green : IState
 40: {
 41:     public void Show()
 42:     {
 43:         Console.ForegroundColor = ConsoleColor.Green;
 44:         Console.WriteLine("Зелений — їдь!");
 45:         Console.ResetColor();
 46:     }
 47:
 48:     public void Next(TrafficLight light)
 49:     {
 50:         light.SetState(new Red());
 51:     }
 52: }
 53:
 54: class TrafficLight
 55: {
 56:     private IState _state;
 57:
 58:     public TrafficLight()
 59:     {
 60:         _state = new Red();
 61:     }
 62:
 63:     public void SetState(IState state)
 64:     {
 65:         _state = state;
 66:     }
 67:
 68:     public void Change()
 69:     {
 70:         _state.Show();
 71:         _state.Next(this);
 72:     }
 73: }
 74:
 75: class Program
 76: {
 77:     static void Main()
 78:     {
 79:         var light = new TrafficLight();
 80:
 81:         for (int i = 0; i < 9; i++)
 82:         {
 83:             light.Change();
 84:             Thread.Sleep(500);
 85:         }
 86:     }
 87: }

	Другий приклад:
  0: using System;
  1:
  2: interface IState
  3: {
  4:     void Handle(AlarmSystem system);
  5: }
  6:
  7: class Activated : IState
  8: {
  9:     public void Handle(AlarmSystem system)
 10:     {
 11:         Console.WriteLine("Alarm activated");
 12:         system.SetState(new Alarm());
 13:     }
 14: }
 15:
 16: class Alarm : IState
 17: {
 18:     public void Handle(AlarmSystem system)
 19:     {
 20:         Console.WriteLine("Alarm triggered!");
 21:         system.SetState(new Deactivated());
 22:     }
 23: }
 24:
 25: class Deactivated : IState
 26: {
 27:     public void Handle(AlarmSystem system)
 28:     {
 29:         Console.WriteLine("Alarm deactivated");
 30:         system.SetState(new Activated());
 31:     }
 32: }
 33:
 34: class AlarmSystem
 35: {
 36:     private IState _state;
 37:
 38:     public AlarmSystem()
 39:     {
 40:         _state = new Activated();
 41:     }
 42:
 43:     public void SetState(IState state)
 44:     {
 45:         _state = state;
 46:     }
 47:
 48:     public void Trigger()
 49:     {
 50:         _state.Handle(this);
 51:     }
 52: }
 53:
 54: class Program
 55: {
 56:     static void Main()
 57:     {
 58:         var alarmSystem = new AlarmSystem();
 59:
 60:         for (int i = 0; i < 6; i++)
 61:         {
 62:             alarmSystem.Trigger();
 63:         }
 64:     }
 65: }
